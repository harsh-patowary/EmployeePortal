Chapter 2: TECHNICAL DOCUMENTATION

	Technology Stack
For the Backend, I chose the Django REST Framework because of its robust ORM, built-in authentication system, and excellent serialisation capabilities. Python’s readability and extensive library ecosystem make it perfect for implementing complex business logic

Backend:
	Python 3.11
	Django 5.1
	Django REST Framework
	PostgreSQL
	JWT Authentication (via Simple JWT
Frontend:
	React 18
	Redux (with ReduxToolkit
	Material UI
	React Router
	Axios
	date-fns



	Project Structure

I organised the project with a clear separation between backend frontend concerns:

















This structure reflects my belief in feature-based organisation  rather than type-based organisation. Each feature module contains everything needed (components, services, state) to implement that specific feature, making the codebase more maintainable and understandable





 
	Backend Implementation 

3.1 Django Applications
Structuring the backend in a manner where the “features” of the app are isolated in apps layer and the main settings and the main system architecture of the system (i.e. the routing, installed apps, dependencies), hence making it easier for scalability and faster development in terms of integrating new features in the backend 

3.1.1 Employee Management
The employee app is the core of the system, handling user authentication and employee data. I used Django’s built-in user model and extended it with an Employee model to store job-specific information
A key insight I implemented was the hierarchical role system. While many systems use Boolean flags for permissions, I created a more nuanced approach.

Models: 
The Employee Model extends Django’s User model through a OneToOneField relationship, adding employment-specific fields.


This creates a tree structure where employees report to managers, who might report to admins or directors. This made implementing feature like leave approval workflows much more intuitive







Views:
The employee app includes several critical views that form the foundation of our authentication system: 


The get_user_details() function's view retrieves complete employee information, handling role-based UI customisation


The get_manager_team() view is crucial for managers or any other management staff with the right permissions to access their team’s data throughout the app.

Serializers: 
The employee app includes several serializers that transform data between Django models and JSON




The EmployeeDetailSerializer extends this with nested manager information:

URL configuration:
The employee app’s URL patterns define the authentication endpoints

		
		The manager-team/ endpoint gets the team of the logged in employee. The employee app in general, is used to implement an app-wide state management system.








Admin Interface:
The Django admin site is customized to provide a user-friendly interface for employee user account management




3.1.2 Attendance Management
For attendance tracking, I designed a system that balances simplicity with powerful features. Each attendance record links to an employee and captures their daily working hours.
Models: 
The attendance model registers object attributes like the employee, which is a Foreign Key which acts as a foreign key to the Employees Database, therefore creating a relationship between the models for increased performance.



One challenge I overcame was handling time zone issues. Initially, I used Python’s standard datetime, but this caused the “fromisoformat: argument must be str ” error. I learned to use Django’s timezone utilities consistently for all datetime operations. This ensured consistent handling of times across the application, regardless of where users are located. Also this allowed me to pass the time for Attendance attributes like check_in() and check_out()





Views:
The AttendanceViewSet manages all attendance operations with the specialized action methods.
Custom Permissions:
The IsManagerOrReadOnly permission is important for enforcing role-based access. This helps in rendering a dynamic attendance dashboard that displays the selected components depending on the role of the user. 
For example (User Story)
A team consisting of 6 team members and 2 managers, when the team members are on the EMS they cannot access the attendance dashboard because of the RBAC the component does not render; they can only check in, check out, and see only their attendance records in the EmployeeAttendanceDashboard. But a manager of a team can see their records own records in the EmployeeAtendanceDashboard and since their role is manager, they can access the collective record of their team. 



Serializers:
The AttendanceSerializer handles both data display and model validation

This class is also responsible for logging valid check-in and check out times and the duration of work
URL Configuration
The attendance URLs are configured using Django REST Framework’s default router. I decided to implement the DefaultRouter as a third party router like SimpleRouter which is the same as DefaultRouter but doesn’t not have a default API root view which makes it a little bit inconvenient for rapid prototyping and testing and other Routers like drf-nested-routers are powerful when implementing nested or hierarchical API’s
This creates endpoints like 
	/api/attendance/ - List all attendance records (GET) or create a new one (POST)
	/api/attendance/{id}/ - Retrieve, update or delete a specific attendance record
	/api/attendance/check_in/ -Record employee check in
	/api/attendance/{id}/history/ - Get attendance history for an employee
For a streamlined development process I tested the endpoints with the Postman API before moving onto the frontend so that I have a strong foundation to build on.

Admin Interface:
The attendance admin enhances management capabilities:
	Shows employee records with time details 
	Filters by status and date
	Provides date-based navigation with date_hierarchy
This is mainly used by the in-built Django CMS

















3.1.3 Leave Management 

The leave management system was particularly a interesting to implement because it needed a multi step approval workflow. I created a status field that tracks the request  through the lifecycle




Models:
The LeaveRequest Model is well structured for scalability, clarity, and role-based workflows. It cleanly separates leave types and approval states using ENUMS (STATUS_CHOICES), making it easy to manage and extend. By using the ForeignKey relationship for employee, approved_by_manager, and approved_by_hr, it supports auditable approvals and role-based filtering. Timestamps fields enable robust tracking of the request lifecycle and the duration_days property simplifies the business logic. 



Views:
The LeaveRequestViewSet implements the complex workflow system. 





 
The get_queryset(self) function is where we dynamically control which leave requests a user gets to see. We base this on:
	Their role (employee.role)
	A scope query param (?scope=my, pending_approval, or all)
Supported Scopes:
	my → Show leave requests submitted bu the logged-in user
	pending_approval → Show leave request waiting for the logged-in user’s approval 
	all → Only HR/Admin. Directors can see everything
	Default → A fallback view based on user rple (eg managers see their teams pending + their own [this should not happen, this is a bug that I was not completely able to resolve, so it is a feature now! ] )
This logic ensures that:
	Employees don’t see anything that shouldn’t 
	“Approvers” see only what they’re supposed to act on 
	HR/Admins/Directors get a broader view

In the get_permissions(self) function we assign permission classes based on the action:
For example :
	Creating a request? Just need to be authenticated
	Approving as a manager? Must pass IsRequestManager. [Bug: CE301-44]
	Viewing all requests? Only allowed for HR via isHR 
This keeps our permissions clean and tight per use case.

The perform_create(self, serializer) auto-links the request to the logged-in user’s employee profile, and sets an appropriate initial status based on the role of the user:
	Director  → Skip manager approval. Goes directly to HR (manager_approved)
	Everyone else → Standard flow (pending)
The system also simulates notification logs with the print() (could easily be swapped with real emails or push notifications later)

@action approve_manager
This endpoint is for managers (or Admins/Directors) to approve a pending leave request
What it does is:
	It validates if the request is pending
	It changes the status to manager_approved
	Tracks who approved it when 
	Sends a notification to requesting employee (via print for now
This moves the request forward to HR for the final step/approval
Later in the view set, there are methods like approve_hr, reject_manager, reject_hr, and cancel coming up right after this, These functions too follow the same pattern:
	Check permissions and request status
	Update the request accordingly 
	Log the change and notify people

Role	Can view	Can Approve
Employee	Their own only	❌
Manager	Their Team’s requests 	✅(approve_manager)
HR 	Manager-approved requests	✅(approve_hr)
Admin	Acts as Manager for “Managers” and “hr”	✅both
Director	Skips Manager stage	✅(HR Approval needed)

A few things to be noted:
	If an Employee doesn’t exist for a user(some edge cases), we return an empty queryset to avoid errors
	Permissions are strict and composable -  easy to plug in more roles in the future
	In Future implementation, print() should/ can be replaced with a proper notification system

Custom Permission:
These Two permission classes – IsRequestManager and IsRequestManager – help enforce who can do what with leave requests. They’re the gatekeepers that make sure only the right people can view or act on a request.

IsRequestOwner
This is the “my requests only” bouncer. It checks if the loggeg-in user is the one who made the leave request.
This is mainly used in actions where users should only touch their own data – viewing updating, or cancelling their requests. 
	Firstly it ensures the user is authenticated 
	Then it tries to match the requests employee.user with request.user
	If that fails (eg. Some weird edge case), it gradually return False 

IsRequestManager
This permission checks if the logged-in user is allowed to approve or reject a given leave request.
Who can approve?
	The direct manager of the person who made the request
	OR someone with an elevated role like admin or director(basically, higher-up
We need this dual case for approval because sometimes HR or higher management might need to step in – this logic handles both scenarios. This way manager can manage, but the admin/directors can override or assist when needed.  
How it works:
	Successful authentication 
	Proceed to check if user is:
	The requester’s manager
	OR in an elevated role like admin or director
	Otherwise do not show   

Serializers:
The LeaveRequestSerializer is responsible for transforming LeaveRequest model instances into a structured and human-friendly API representation. It also enforces validation rules and ensures fields are read-only depending on the user’s role or stage of the workflow

This is a DRF Serializer that works closely with ethe LeaveRequest model. It includes both raw model foelds and computd display fields to improve the readability and usability of the data returned by the API


Custom Fields for the LeaveRequestSerializer
For better usability of the model additional and a few customized fields were included beyond the model’s default
	employee_detail: 
	Uses EmployeeSerialixer to nest deailed employee information. Read-Only (Good for displaying employee data without a separate API call)
	status_display: 
	Returns the human readable display version of the status field (eg Pending instead of “P”), Read Only
	leave_type_display:
	Similar to status_display, this return the verbose name or the leave_type. Read-Only
	approved_by_manager_name: 
	Returns the full name of the approving manager (if available). Read-only and supports null
	duration_days: 
	A computed integer representing the total number of leave days between start_data and end date. Read-Only

Meta Configuration

A full list of fields to be serialized, including primary keys, relational fields, timestamps, and custom display fields. All computer values and system-managed fields (like approval timestamps, status, or who approved the request) are marked as read-only prevent tampering from the client side. This ensures a clear separation between what users can submit and what the system manages internally
Validation Logic validate(self, data)
This method ensures that the user submits a valid date range for their leave request
	Rule Enforced:
	The end_date must be earlier than the start_date
	Importance:
	Prevents invalid data from reaching the business logic layer and maintains data integrity early in the pipeline

The LeaveRequestSerializer is carefully designed to balance flexibility and control:
	Allows employees to submit and view their requests easily.
	Safeguards sensitive or system-managed fields via read-only settings
	Improves UX by exposing human-readable names and computed fields
	Ensure basic validation before processing leave data

URL Configuration
The leave management URL’s also use the DefaultRouter make it easier to add routing calls.

urls.py – This file defines the URL configuration for the leave management module within the broader employee management system. It leverages DRF’s DefaultRouter to automatically generate RESTful API routes for the LeaveRequestVewSet
DRF’s DefaultRouter provides a quick and standardized way to generate all CRUD endpoints for viewset. While not always a requirement but mentioning 
basename= ‘leave-request’ ensures route naming stays predictable, especially when get_queryset() is customized inside the viewset.
This creates endpoints like:
	/api/leave/requests/ → List leave requests or create a new one
	/api/leave/requests/{id}/ → Get details, update or delete a specific request
	/api/leave/requests/{id}/approve_manager/ → Manager approval action
	/api/leave/requests/{id}/approve_hr/ → HR approval action
	/api/leave/requests/{id}/reject_manager/ → Manager rejection action
	/api/leave/requests/{id}/reject_hr/ → HR rejection action
	/api/leave/requests/{id}/cancel/ → Cancel a leave request

Admin Interface
The leave Management admin interface provides tools for administrators. This class is responsible for how LeaveRequest model appears and behaves within the Django admin 
Key Features
	list_display:
	Displays important fields in the list view – useul for quickly scanning leave requests
	list_filter: adds side bar filters for efficient filtering by: 
	Leave Status
	Leave type 
	Start date 
	Employee’s Department
	search_fields: Enables search functionality using
	Employee’s first name
	Last name
	Email 
	leave reason
	readonly_fields: Ensures fields are locked for editing to preserve integrity





	Frontend Implementation
This section provides a comprehensive overview of the React application architecture, key components, and the patterns I used to implement different features throughout the system.

4.1 Key Frontend (React.js) libraries

	React Router DOM (v7.3.0): For application routing and navigation
	Redux Toolkit (v2.6.1): For state management across the application
	Material UI (v6.4.7): Component library for consistent UI design
	Axios (v1.8.3): For HTTP requests to the backend API
	Date-fns (v2.30.0): For date manipulation and formatting
	Recharts (v2.15.3): For data visualization
	Redux Persist: For persisting authentication state across sessions

4.3 Frontend Architecture

4.3.1 Directory Structure:
	
	









4.3.2 State Management

The frontend uses Redux Toolkit for state management with separate slices for different domains (basically every feature has its own slice)
	employeeSlice: Manages user data, authentication state, role permissions
	authSlice: Handles the authentication related operations
	leaveSlice: Manages leave requests and approvals
	noticeSlice: Handles notice/announcements/memos data

4.3.3 Core Components
	The base layout components
AppLayout 
(src/layout/AppLayout.js)
	App bar with user information and theme toggle 
	Profile menu dropdown with the logout options
	Responsive sidbar navigation
	Main content are with proper spacing
Sidebar
		(src/layout/Sidebar.js)
	Dynamic menu items based on user role
	Active route highlighting 
	Responsive designs that collapses on mobile 
	Logout functionality

4.3.4 Authentication and Authorisation
ProtectedRoute
(src/components/ProtectedRoute.js)
	Verifying the user authentication state
	Redirect the user to login if unauthenticated 
	Showing loading state during authentication checks
	Handling token refreshes automatically

PermissionGate
(src/components/PermissionGate.js)
Controls access to features based on user roles and permission (for RBAC implementation):


4.3.5 Dashboard Widgets
The Dashboard uses a widget-based architecture that makes it easy to add remove, or rearrange content:
		DashboardWidget
		(src/pages/DashboardPage.js)
A container component that provides styling and behaviour for dashboard widgets, and their placement and alignment in the dashboard screen.

Feature widget include:
	User profile summary 
	Attendance statistics
	Leave Management summary
	Recent Notices



4.3.6 Feature Modules

Attendance Management

The attendance feature provides functionality for tracking employee attendance with:
	Calendar view for historical data
	List view with filtering and sorting
	Team attendance tracking for managers
	Attendance form for data entry
Key components:
	AttendanceDashboard: Main page for managers
	EmployeeAttendancePage: Simplified view for regular employees
	AttendanceList: Sortable table of attendance records
	TeamAttendanceCalendar: Calendar visualisation of team attendance

Leave Management

The leave feature allows employees to request time off and managers to approve requests:
	Leave request form with type selection and date ranges
	Balance display showing available leave days
	Approval workflows for managers and HR
	Status tracking for pending and processed requests
Key components:
	LeaveDashboardPage: Central hub for leave management
	LeaveRequestForm: Form for submitting new leave requests
	LeaveRequestList: Display of leave requests with filtering
	ApprovalActionDialog: Interface for managers to approve/reject requests



Notice Board

The notice system enables company-wide and targeted communications:
	Notices categorized by scope (company, department, team, direct)
	Priority-based highlighting
	Detail view for complete information
	Creation form with rich text support
Key components:
	NoticeDashboardPage: Main interface for viewing notices
	NoticeList: Displays notices with filtering options
	NoticeForm: Form for creating new notices
	NoticeDetailDialog: Modal for viewing complete notice details

Task Management

The task management is just a functional frontend component for the design implementation of having a to-do list but later on can be used to assign team-wide work specifically assigned to somebody although I could not completely implement the feature basic Task addition and status assignments work for a single session.


		








4.3.7 Routing Structure

The application uses React Router with a nested route structure

<Route path="/login" element={<LoginPage />} />
	This is a public route that renders the LoginPage component when the URL is /login.
	No authentication is needed to access this.

<Route path="/" element={<Navigate to="/dashboard" replace />} />
	When a user navigates to /, they are automatically redirected to /dashboard.
	The replace prop ensures that the redirect doesn't leave a history entry, so the back button won't take them back to /.


<Route path="/" element={<ProtectedRoute><LayoutWrapper /></ProtectedRoute>}>
	This wraps all the following routes inside a ProtectedRoute, meaning the user must be authenticated to access them.
	Inside ProtectedRoute, the LayoutWrapper likely provides shared layout like the sidebar, navbar, etc.

Pages inside the Layout (Authenticated Users)
<Route path="dashboard" element={<DashboardPage />} />
<Route path="profile" element={<ProfilePage />} />
<Route path="my-attendance" element={<EmployeeAttendancePage />} />
<Route path="leave" element={<LeaveDashboardPage />} />
<Route path="projects" element={<ProjectsPage />} />
<Route path="tasks" element={<TasksPage />} />
<Route path="settings" element={<SettingsPage />} />
<Route path="notices" element={<NoticeDashboardPage />} />
	These Routes are only accessible after login
	Each one corresponds to a different section of the app
Manager-Only Routes (RBAC)
<Route path="attendance" element={
  <ProtectedRoute requiredRole="manager">
    <AttendanceDashboard />
  </ProtectedRoute>
} />
<Route path="reports" element={
  <ProtectedRoute requiredRole="manager">
    <ReportsPage />
  </ProtectedRoute>
} />
	These routes are only accessible to users with the manager role
	The requiredRole=”manager prop in ProtectedRoute ensures role-based protection
Routes Table

Route Path	Component Rendered	Access Type
/login	LoginPage	Public
/	Redirect to /dashboard	Public
/dashboard	DashboardPage	Protected
/profile	ProfilePage	Protected
/my-attendance	EmployeeAttendancePage	Protected
/leave	LeaveDashboardPage	Protected
/projects	ProjectsPage	Protected
/tasks	TasksPage	Protected
/settings	SettingsPage	Protected
/notices	NoticeDashboardPage	Protected
/attendance	AttendanceDashboard	Manager Only
/reports	ReportsPage	Manager Only

4.4 Theming and Styling
The web app can support both light and dark modes through a custom theme provider:
<ThemeProviderWrapper>
  <App />
</ThemeProviderWrapper>
Material UI's theming system is used throughout with custom palette configuration and consistent component styling. Theme preferences are persisted in local storage for a seamless user experience.




4.5 UI Design Patterns
The UI of the application follows all modern design principles to ensure a seamless and user-friendly experience across all devices. Here how these design patterns are being implemented
Every element and page fluidly adjusts to various screen sizes by combining:

Responsive Breakpoints: To guarantee the best possible readability and usability, the layout adapts at significant breakpoints (such as desktop, tablet, and mobile).


Conditional rendering reduces clutter and enhances mobile usability by displaying or hiding specific elements (such as tooltips, sidebar buttons, or extended menus) according to screen size.

Collapsible Sidebar: To save room and preserve navigation accessibility on smaller screens, the sidebar automatically folds into a drawer resembling a hamburger.

Adaptive Typography & Spacing: To preserve legibility and visual harmony, font sizes, margins, and paddings are sized suitably for smaller viewports.

4.6 Loading & Error States
The application's reliable techniques for handling asynchronous operations improve the user experience when data is being fetched or an error occurs. 

Loading Indicators: Each website or data-dependent component displays spinners, skeletons, or shimmer effects to communicate activity and avoid blank states. 

Error Feedback: Useful error messages, often with retry buttons or fallback information, are displayed when anything goes wrong, such as network issues or unsuccessful API calls. 

Global and Component-Level Handling: Some loading/error states are handled globally (e.g., through context or layout wrappers), while others are controlled at the component level for more accurate control.


	Methodology

gave serious thought to the best way to oversee the development process when I first began working on the Employee Management Portal. Since the Agile methodology seemed suitable for this type of project, I chose to employ it. Agile's focus on flexibility appeared to be ideal for managing the learning and development that frequently occur throughout the process of developing web applications. I decided to use Jira as my main project management application in order to efficiently track my work and keep things organized. 
How I Applied Agile Principles: Rather than just adhering to a set of guidelines, I felt that using Agile meant embracing its fundamental concepts. It was essential to break down the larger picture—the Employee Management Portal as a whole—into smaller, easier-to-manage tasks. 
For example, I used Jira to break down the project, "Build Attendance Feature," into smaller, easier-to-manage activities or user stories. These may have included things like "Design the attendance calendar interface," "Implement the database logic for check-in/out times," or "Develop the report generation for managers." 
This approach allowed me to focus on one specific element at a time, finish it, then move on to the next. It made the process appear less daunting overall and allowed me to observe actual progress more frequently. It also meant that, in light of testing or new knowledge, I could make any necessary changes without totally reversing the project plan.
Regular self-assessment and adapting the plan as needed were key parts of my process.
Using Jira to Stay on Track:
Jira was my digital command center for this project. I made a project board that graphically represented the many stages of my workflow. My typical columns were 'To Do' (items I needed to start), 'In Progress' (items I was working on at the time), 'In Review' (for self-evaluation or testing), and 'Done' (items I had finished). 
For every task, bug fix, and feature improvement I discovered, I made a Jira "issue". Tracking became much simpler when each issue was given a unique identification number (for instance, CE301). I could give more details, notes, and approval criteria for every issue. I prioritized these issues based on what seemed most critical for the portal's development at any given time, ensuring I was always working on the most impactful items first. This visual board gave me a clear snapshot of where things stood at any moment.


Connecting Code Changes Back to Jira (The CE301 Workflow):
A crucial part of my workflow was making sure my actual coding work was clearly linked to the tasks I had defined in Jira. This traceability is really important for understanding the project's history. You mentioned seeing "CE301" in commit messages – that's exactly this process in action!
Here’s how I typically handled it when working on a task identified in Jira, let's use CE301 as the example key:
	Creating a Branch: Before writing any code for the task, I created a dedicated Git branch. I made sure to name the branch descriptively, including the Jira issue key. For example:
	feature/CE301-team-calendar-styling
	bugfix/CE301-resolve-date-format-issue
	Making Commits: As I made progress and saved changes to the code on that branch, I wrote clear commit messages. Critically, I always included the Jira key (CE301) at the beginning of the message. This provided immediate context for each change:
	git commit -m "CE301: Add initial CSS structure for TeamAttendanceCalendar"
	git commit -m "CE301: Refine border styles for attendance status cells"
	git commit -m "CE301: Adjust padding for better mobile view"
This habit meant that looking back through the Git history, I (or anyone else) could instantly see which Jira task (CE301) a specific code change related to. It connected the project management side directly to the codebase.




 
